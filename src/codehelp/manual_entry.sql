-- Insert 15 entries with updated response_json and response_text values
INSERT INTO queries (query_time, context_name, context_id, context_string_id, code, error, issue, response_json, response_text, topics_json, helpful, user_id, role_id)
VALUES 
    ('2024-11-30 10:00:00', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    return abs(len(s1) - len(s2))\nprint(levenshtein_distance("hello", "mellow"))', '', 'Im only using the difference in string lengths, but it doesnt seem correct. How can I account for substitutions too?', '{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 5, 2),
    ('2024-11-30 10:01:30', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    dp = [[0] * len(s1) for _ in range(len(s2))]\n    return dp[-1][-1]', '', 'Ive started creating the DP table, but Im not sure how to initialize it or fill it properly. What should the base case look like?', '{}', '{"main": "response"}', '{"topic": "passwords"}', 1, 5, 2),
    ('2024-11-30 10:02:15', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    return len(s1) + len(s2) - 2 * len(set(s1).intersection(s2))','', 'I tried using set intersections to simplify the calculation, but the results are inaccurate. Why is this approach flawed?','{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 5, 2),
    ('2024-11-30 10:03:45', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    dp = [[0 for _ in range(len(s2))] for _ in range(len(s1))]\n  for i in range(len(s1)):\n  dp[i][0] = i\n    return dp[-1][-1]', '', 'I initialized the first column but dont know how to proceed for the other cells. Any tips?', '{}', '{"main": "response"}', '{"topic": "passwords"}', 1, 4, 3),
    ('2024-11-30 10:04:30', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    for i in range(len(s1)):\n  if s1[i] != s2[i]:\n  return i\n  return 0', '', 'This only works for strings of the same length. How can I adapt it for strings of different lengths?', '{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 4, 3),
    ('2024-11-30 10:05:20', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    if not s1 or not s2:\n  return len(s1) + len(s2)\n    return 1 + levenshtein_distance(s1[1:], s2[1:])','', 'I get a recursion error for longer strings. How can I optimize this recursive solution?','{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 4, 3),
    ('2024-11-30 10:06:45', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    dp = [[0 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n for i in range(len(s1)+1):\n for j in range(len(s2)+1):\n  dp[i][j] = dp[i-1][j-1]\n return dp[-1][-1]', '', 'My DP table seems to fill incorrectly. Should I handle insertions, deletions, and substitutions separately?','{}', '{"main": "response"}', '{"topic": "passwords"}', 1, 4, 3),
    ('2024-11-30 10:07:05', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    return len([1 for a, b in zip(s1, s2) if a != b])', '', 'This counts character differences but ignores insertions and deletions. How do I account for these operations?','{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 3, 4),
    ('2024-11-30 10:08:10', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n for i in range(len(s1) + 1):\n  dp[i][0] = i\n for j in range(len(s2) + 1):\n  dp[0][j] = j\n return dp[len(s1)][len(s2)]','', 'I initialized the first row and column, but my table isnt updating after initialization. What step am I missing?','{}', '{"main": "response"}', '{"topic": "passwords"}', 1, 3, 4),
    ('2024-11-30 10:09:30', 'fx1', 4, 1, 'def levenshtein_distance(s1, s2):\n    return min(\n  levenshtein_distance(s1[:-1], s2),\n levenshtein_distance(s1, s2[:-1]),\n  levenshtein_distance(s1[:-1], s2[:-1])\n    ) + 1','', 'This recursive approach is too slow for larger inputs. How can I memoize the results to improve efficiency?','{}', '{"main": "response"}', '{"topic": "passwords"}', 0, 3, 4)
